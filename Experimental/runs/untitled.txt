cd ~/Ulmer-Berechnung/modular_alps2qutipplus
export PYTHONPATH=$(pwd)


python -m Experimental.runs.main --size 7 --Jx 1.75 --Jy 1.575 --Jz 0.0 \
    --t_max 30 --steps 60 --depth 6 --m0 3 --eps 1e-3 \
    --num_workers 3 --save_every 20 --out results --count_basis


$ python -m Experimental.runs.main --size 7 --Jx 1.3 --Jy 0.83 --Jz 0. --t_max 10 --steps 150 --depth 6 --m0 2 --eps 1e-3 --num_workers 3 --save_every 20 --out results


python -m Experimental.runs.main --size 6 --Jx 1.5 --Jy 1.2 --Jz 0. --t_max 10 --steps 200 --depth 5 --m0 3 --eps 1e-5 --num_workers 4 --save_every 20 --out results



if count_basis:
            if idx % basis_step == 0:
                try:
                    flat_list = flatten_to_product_terms(HBB[0].as_sum_of_products())
                    if m0 >= 3: 
                        flat_list = [plME.general_worker(("projection", (op, 2, sigma_act))) for op in flat_list]
                    ortho = orthogonalize_operators(flat_list, sp_local)
                    sim["orth_lens"].append(len(ortho))
                except RuntimeError:
                    sim["orth_lens"].append(-1)
            else:
                sim["orth_lens"].append(-1)

        # instantaneous commutator bound
        local_next_op = (idop - 1j* plME.commutator_worker((H, HBB[-1]))).simplify()
        sim["ints_err"].append(sp_local(local_next_op, local_next_op))
        
        
        
        
        
        
        
        
        
        
        
        
        
def run_simulation(
    sim_id: int,
    params: dict,
    system_objects: dict,
    timespan: np.ndarray,
    save_every: int,
    out_dir,
    *,
    num_workers: int = 2,
    count_basis: bool = False,
    basis_step: int = 1,  # compute orth_len every `basis_step` iterations
):
    """Adaptive Heisenberg‐picture simulation with optional basis diagnostics.

    Columns saved per checkpoint:
      * t
      * ev          – approximate expectation value
      * ev_exact    – exact (qutip) expectation value
      * orth_len    – |orth basis| (every `basis_step` if `count_basis`)
      * ints_err    – instantaneous ∫ ||[H, O_last]|| bound (every step)
    """

    tag = (
        f"Jx{params['Jx']}_Jy{params['Jy']}_Jz{params['Jz']}"
        f"_ell{params['chosen_depth']}_m{params['m0']}_eps{params['eps']}"
    )
    
    sim_out_dir = Path(out_dir) / tag
    sim_out_dir.mkdir(parents=True, exist_ok=True)
    print(f"[INFO] Simulation outputs will be saved to: {sim_out_dir}")

    idop, H, K0, sigma0, tgt_obs = (
        system_objects["idop"],
        system_objects["H"],
        system_objects["K0"],
        system_objects["sigma0"],
        system_objects["obs"],
    )

    vLR = Heisenberg_vLR(params)
    res_exact = mesolve(H.to_qutip(), sigma0.to_qutip(), tlist=timespan, e_ops=[tgt_obs.to_qutip()])
    ev_exact_arr = np.asarray(res_exact.expect[0], dtype=complex)

    sim = {
        "evs": [(sigma0 * tgt_obs).tr()],
        "evs_exact": [ev_exact_arr[0]],
        "ints_err": [],
    }
    if count_basis:
        sim["orth_lens"] = []

    sigma_act = sigma0
    sp_local = fetch_covar_scalar_product(sigma0)
    chosen_depth, m0 = params["chosen_depth"], params["m0"]

    HBB = plME.parallelized_real_time_projection_of_hierarchical_basis(
        generator=H,
        seed_op=K0 + 1e-10 * H,
        sigma_ref=sigma0,
        nmax=m0,
        deep=chosen_depth,
        num_workers=num_workers,
    )
    
    HBB = [op.tidyup(1e-7) for op in HBB]
   
    Gram = plME.parallel_gram_matrix_fine(HBB, sp_local, num_workers=num_workers)
    R = np.linalg.cholesky(Gram).conj().T
    b_orth = np.linalg.inv(R.T) @ HBB

    Hij = np.linalg.inv(R).T @ plME.compute_Hij_tensor_non_orth(
        basis=HBB, generator=H, sp=sp_local, sigma_ref=sigma0,
        nmax=m0, Gram=Gram, num_workers=num_workers) @ np.linalg.inv(R)
    phi0 = np.array([sp_local(K0, op) for op in b_orth])
    
    idx = 0
    if False: ### TODO: too expensive, unstable and I dont want to do it know
        if idx % basis_step == 0:
            local_next_op = (idop - local_next_op).simplify()
            sim["ints_err"].append(sp_local(local_next_op, local_next_op))
        else:
            sim["ints_err"].append(-1)
    
    if count_basis: ### Expensive so only convenient to do it sometimes 
        flat_list = flatten_to_product_terms(HBB[-1].as_sum_of_products())
        if m0 >= 3:
            flat_list = project_flat_list(flat_list, sigma_act, num_workers=params.get("num_workers", 2))
        ortho = orthogonalize_operators(flat_list, sp_local)
        sim["orth_lens"].append(len(ortho))

    recorded_times: List[float] = [timespan[0]]
    for idx, t in enumerate(timespan[1:], start=1):
        dt = t - recorded_times[-1]
        phi0 = np.real(linalg.expm(dt * Hij) @ phi0)       # <‑‑ advance state *and* store back
        K_local = (phi0 @ b_orth).simplify().tidyup(1e-7)
        ev_val = (GibbsDensityOperator(K_local) * tgt_obs).tr()
        
        sim["evs"].append(ev_val)
        sim["evs_exact"].append(ev_exact_arr[idx] if idx < len(ev_exact_arr) else np.nan)

        # Define the max time up to which to count basis
        t_cutoff = 1.5 * params["size"] /vLR
    
        sim["orth_lens"] = []
        if count_basis and t < t_cutoff:
            if idx % basis_step == 0:
                try:
                    flat_list = flatten_to_product_terms(HBB[-1].as_sum_of_products())
                    if m0 >= 3:
                        flat_list = project_flat_list(flat_list, sigma_act, num_workers=params.get("num_workers", 2))
                    ortho = orthogonalize_operators(flat_list, sp_local)
                    sim["orth_lens"].append(len(ortho))
                except RuntimeError:
                    sim["orth_lens"].append(-1)
            else:
                sim["orth_lens"].append(-1)
        else:
            sim["orth_lens"].append(-1)


        recorded_times.append(t)

        if idx % max(1, len(timespan)//10) == 0 or idx == len(timespan)-1:
            print(f"[PROGRESS] t = {t:.3f} | ev ≈ {ev_val.real:.6f} | ev_exact = {ev_exact_arr[idx].real:.6f}")

        err_ratio = me.m_th_partial_sum(phi=phi0, m=2) / me.m_th_partial_sum(phi=phi0, m=0)
        if abs(err_ratio) >= params["eps"]:
            print(f"[INFO] Error threshold exceeded (err={err_ratio:.3e}), rebuilding basis at t={t:.3f}")
            print(f"        ev ≈ {ev_val.real:.6f} | ev_exact = {ev_exact_arr[idx].real:.6f}")

            sp_local = fetch_covar_scalar_product(sigma0)

            HBB = plME.parallelized_real_time_projection_of_hierarchical_basis(
                generator=H, seed_op=K_local, sigma_ref=sigma0,
                nmax=m0, deep=chosen_depth, num_workers=num_workers)
            
            HBB = [op.tidyup(1e-7) for op in HBB]

            Gram = plME.parallel_gram_matrix_fine(HBB, sp_local, num_workers=num_workers)
            R = np.linalg.cholesky(Gram).conj().T
            b_orth = np.linalg.inv(R.T) @ HBB

            Hij = np.linalg.inv(R).T @ plME.compute_Hij_tensor_non_orth(
                basis=HBB, generator=H, sp=sp_local, sigma_ref=sigma0,
                nmax=m0, Gram=Gram, num_workers=num_workers) @ np.linalg.inv(R)

            phi0 = np.array([sp_local(K_local, op) for op in b_orth])
            
            if False:# instantaneous commutator bound
                if idx % basis_step == 0:
                    local_next_op = (idop - local_next_op).simplify()
                    sim["ints_err"].append(sp_local(local_next_op, local_next_op))
                else:
                    sim["ints_err"].append(-1)

        L = len(recorded_times)
        for key in ["evs", "evs_exact", "ints_err", "orth_lens"]:
            if key in sim:
                while len(sim[key]) < L:
                    sim[key].append(np.nan)

        if idx % save_every == 0 or idx == len(timespan) - 1:
            save_checkpoint(
                sim_id,
                recorded_times,
                sim["evs"],
                evs_exact=sim["evs_exact"],
                out_dir=sim_out_dir,
                step=idx,
                orth_lens=sim.get("orth_lens"),
                ints_err=sim["ints_err"],
            )