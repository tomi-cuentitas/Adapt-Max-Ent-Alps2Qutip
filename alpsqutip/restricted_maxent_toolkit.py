"""
Functions used to run MaxEnt simulations.
"""

from __future__ import annotations

from math import factorial
from typing import Any, Callable, List, Tuple

import numpy as np
import qutip
from numpy.typing import ArrayLike
from qutip import Qobj
from scipy import linalg

from alpsqutip.operators import Operator, QutipOperator
from alpsqutip.operators.functions import commutator
from alpsqutip.operators.states.meanfield.projections import project_to_n_body_operator
from alpsqutip.scalarprod import fetch_covar_scalar_product, orthogonalize_basis

# function used to safely and robustly map K-states to states


def build_hierarchical_basis(
    generator: Operator, seed_op: Operator, deep: int, to_qutip_operator: bool = False
) -> List[Operator]:
    """
    Constructs a hierarchical basis of operators, formed from iterated
    commutators of a seed operator.


    Parameters
    ----------
    generator : Operator
        The generator operator (e.g., a Hamiltonian).
        It should be passed as a QutipAlps operator
        (not Qutip.qobj).
    seed_op : Operator
        The initial seed operator for generating the basis.
        If None, the function will return an empty list.
    deep : int
        An integer indicating the depth of the hierarchy
        (number of iterated commutators).
    to_qutip_operator : bool, optional
        If `True`, convert the operators to its qutip form.
        The default is False.

    Returns
    -------
    List[Operator]
        A list of operators representing the hierarchical basis,
        starting with the seed operator, followed by operators generated by
        successive commutators.

    """

    if to_qutip_operator:
        seed_op = seed_op.to_qutip_operator()
        generator = generator.to_qutip_operator()

    generator = generator * (-1j)
    basis = []
    if deep > 0:
        basis += [seed_op]  # Include the seed operator in the basis.
        for _ in range(deep):
            # Generate new operators by computing the commutator
            # of the generator with the last operator.
            basis.append(commutator(generator, basis[-1]))

    return basis


def fn_hij_tensor(
    basis: List[Operator], sp: Callable, generator: Operator
) -> np.ndarray:
    """
    Computes the Hij-tensor, a local matrix representation of the Hamiltonian
    onto the given basis.

    For each pair of basis operators (op1, op2), the matrix element is defined
    as:
        Hij = sp(op1, commutator(-1j * generator, op2))


    Parameters
    ----------
    basis : List[Operator]
        A list of basis operators..
    sp : Callable
        A callable that defines a scalar product function between two
        operators.
    generator : Operator
        The operator (e.g., Hamiltonian) for which the commutators
        are computed.

    Returns
    -------
    ndarray:
        A real-valued NumPy array representing the Hamiltonian matrix in the
        given basis.
    """

    generator_j = -1j * generator
    local_h_ij = np.array(
        [[sp(op1, commutator(generator_j, op2)) for op2 in basis] for op1 in basis]
    )
    return np.real(local_h_ij)


def fn_hij_tensor_with_errors(
    basis: List[Operator], sp: Callable, generator: Operator
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Computes the Hij-tensor, a local matrix representation of the Hamiltonian
    onto the given basis, and the norm of the orthogonal projector.

    For each pair of basis operators (op1, op2), the matrix element is defined
    as:
        Hij = sp(op1, commutator(-1j * generator, op2))


    Parameters
    ----------
    basis : List[Operator]
        A list of basis operators..
    sp : Callable
        A callable that defines a scalar product function between two
        operators.
    generator : Operator
        The operator (e.g., Hamiltonian) for which the commutators
        are computed.

    Returns
    -------
    local_h_ij : ndarray
        A real-valued NumPy array representing the Hamiltonian matrix in the
        given basis.        .
    errors_w : ndarray
        coefficients to span the norm of the orthogonal projection.

    """

    hgen = -1j * generator
    comm_h_ops = [commutator(hgen, op2).simplify() for op2 in basis]

    local_h_ij = np.zeros([len(basis), len(basis)], dtype=complex)
    for i, b in enumerate(basis):
        for j, comm_op in enumerate(comm_h_ops):
            res = sp(b, comm_op)
            local_h_ij[i, j] = res

    proj_comm_norms_sq = (sum(col**2) for col in local_h_ij.transpose())
    comm_full_norms_sq = (sp(comm_op, comm_op) for comm_op in comm_h_ops)

    errors_w = [
        (max(full_sq - proj_sq, 0.0)) ** 0.5
        for full_sq, proj_sq in zip(comm_full_norms_sq, proj_comm_norms_sq)
    ]
    return local_h_ij, errors_w


def k_state_from_phi_basis(phi: np.array, basis: List[Operator]) -> Operator:
    """
    Constructs the operator K from a given set of coefficients and
    basis operators.

    Parameters
    ----------
    phi : np.array
        A NumPy array containing the coefficients for the linear
        combination.
    basis : List[Operator]
        A list of basis operators.

    Returns
    -------
    Operator
        The operator K, defined as the negative linear combination of the basis
        operators weighted by the coefficients in `phi`. If `phi` is shorter
        than the basis, it is padded with zeros.
    """

    if len(phi) < len(basis):
        phi = np.array(list(phi) + [0.0 for _ in range(len(basis) - len(phi))])
    return sum(phi_a * opa for phi_a, opa in zip(phi, basis))


def slice_times(tlist: np.array, tcuts: List[float]) -> List[np.ndarray]:
    """
    Divides a time list (`tlist`) into slices based on a sequence of cutoff
    times (`tcuts`).

    Parameters
    ----------
    tlist : np.array
        A NumPy array of time values to be sliced.
    tcuts : List[float]
        A list or array of cutoff times used to define the time slices.

    Returns
    -------
    List[ndarray]
        A list of NumPy arrays, where each array corresponds to a segment of
        `tlist`
        based on the intervals defined by `tcuts`.
        - The first slice includes times up to `tcuts[1]`.
        - Subsequent slices include times between `tcuts[d-1]` and `tcuts[d]`.
        - If there are remaining times beyond `tcuts[-1]`, they are included
        in the last slice.

    """

    sliced_times = [np.array([t for t in tlist if t <= tcuts[1]])]

    for d in range(2, len(tcuts)):
        local_tlist = np.array([t for t in tlist if tcuts[d - 1] <= t <= tcuts[d]])
        sliced_times.append(local_tlist)

    if tlist[-1] > tcuts[-1]:
        sliced_times.append(np.array([t for t in tlist if t >= tcuts[-1]]))

    return sliced_times


def m_th_partial_sum(phi: np.ndarray, m: int) -> float:
    """
    Computes the $m$-th partial sum of the squared magnitudes of the last `m`
    coefficients of `phi`.

    Parameters
    ----------
    phi : ndarray
        A NumPy array containing coefficients.
    m : int
        An integer specifying how many of the last coefficients to include
        in the sum.

    Returns
    -------
    float
        The partial sum of the squared magnitudes of the last `m` coefficients
        in `phi`.

    """
    if m >= len(phi) or m < -len(phi):
        return sum(abs(phi_n) ** 2 for phi_n in phi)
    return sum(abs(phi_n) ** 2 for phi_n in phi[-m:])


def qutip_me_solve(
    H: Operator,
    rho0: Operator,
    tlist: ArrayLike,
    *,
    c_ops: list[Operator] | dict[Any, Operator] | Callable[[float, "Qobj"], Any] = None,
    e_ops: list[Operator] | dict[Any, Operator] | Callable[[float, "Qobj"], Any] = None,
    args: dict[str, Any] = None,
    options: dict[str, Any] = None,
) -> List[Operator]:
    """
    Compute the solution of the Schrödinger equation using qutip.mesolve

    Parameters
    ----------
    H : Operator
        Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
        QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that
        can be made into :obj:`.QobjEvo` are also accepted.

    rho0 : Operator
        initial density matrix or state vector (ket).
    tlist : *list* / *array*
        list of times for :math:`t`.
    c_ops : list[Operator] | dict[Any, Operator]
            | Callable[[float, "Qobj"], Any], optional
        Single collapse operator, or list of collapse operators, or a list
        of Liouvillian superoperators. None (default) is equivalent to an empty
        list.
    e_ops : list[Operator] | dict[Any, Operator]
            | Callable[[float, "Qobj"], Any], optional
        Single operator, or list or dict of operators, for which to evaluate
        expectation values. Operator can be Qobj, QobjEvo or callables with the
        signature `f(t: float, state: Qobj) -> Any`.
    args : dict[str, Any], optional
        dictionary of parameters for time-dependent Hamiltonians and
        collapse operators.

    options : dict[str, Any], optional
        Dictionary of options for the solver.

        - | store_final_state : bool
          | Whether or not to store the final state of the evolution in the
            result class.
        - | store_states : bool, None
          | Whether or not to store the state vectors or density matrices.
            On `None` the states will be saved if no expectation operators are
            given.
        - | normalize_output : bool
          | Normalize output state to hide ODE numerical errors. Only normalize
            the state if the initial state is already normalized.
        - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}
          | How to present the solver progress.
            'tqdm' uses the python module of the same name and raise an error
            if not installed. Empty string or False will disable the bar.
        - | progress_kwargs : dict
          | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.
        - | method : str ["adams", "bdf", "lsoda", "dop853", "vern9", etc.]
          | Which differential equation integration method to use.
        - | atol, rtol : float
          | Absolute and relative tolerance of the ODE integrator.
        - | nsteps : int
          | Maximum number of (internally defined) steps allowed in one
          ``tlist`` step.
        - | max_step : float
          | Maximum length of one internal step. When using pulses, it
            should be less than half the width of the thinnest pulse.

        Other options could be supported depending on the integration method,
        see `Integrator <./classes.html#classes-ode>`_.
     : TYPE
        DESCRIPTION.

    Returns
    -------
    List[Operator]
        DESCRIPTION.

    """
    if e_ops is not None:
        if isinstance(e_ops, dict):
            e_ops = {
                key: val if isinstance(val, Qobj) else val.to_qutip()
                for key, val in e_ops.items()
            }
        elif isinstance(e_ops, (tuple, list)):
            e_ops = [val if isinstance(val, Qobj) else val.to_qutip() for val in e_ops]

    if c_ops is not None:
        if isinstance(c_ops, dict):
            c_ops = {
                key: val if isinstance(val, Qobj) else val.to_qutip()
                for key, val in c_ops.items()
            }
        elif isinstance(c_ops, (tuple, list)):
            c_ops = [val if isinstance(val, Qobj) else val.to_qutip() for val in c_ops]

    if isinstance(H, Operator):
        H = H.to_qutip()

    result = qutip.mesolve(
        H.to_qutip(),
        rho0.to_qutip(),
        tlist,
        c_ops=c_ops,
        e_ops=e_ops,
        options=options,
        args=args,
    )
    return [QutipOperator(state, system=rho0.system) for state in result.states]


def projected_evolution(
    ham, k0, t_span, order, sigma_0, n_body: int = -1
) -> List[Operator]:
    """
    Compute the solution of the MaxEnt projected Schrödinger equation

    dk
    -- = -i [H, k]
    dt

    as a linear combination of the iterated commutators

    k = sum phi_a(t) Q_a

    Parameters
    ----------
    ham : Operator
        The Hamiltonian operator
    k0 : Operator
        The initial condition
    t_span: np.array
        the times for with the evolution is computed
    order:
        the order of the solution

    n_body: int
        if non-negative, build a solution projected on
        the subspace of n_body operators.

    Returns
    -------
    List[Operator]:
        A list with the solution at times t_span

    """
    h_basis = build_hierarchical_basis(ham, k0, order)
    sp = fetch_covar_scalar_product(sigma_0)
    # Project to n_body subspace if required
    if n_body >= 0:
        h_basis = [
            project_to_n_body_operator(op_b, nmax=n_body, sigma=sigma_0)
            for op_b in h_basis
        ]
    h_basis = orthogonalize_basis(h_basis, sp)
    hij, werrs = fn_hij_tensor_with_errors(h_basis, sp, ham)
    result = []
    phi0 = np.array([sp(b_op, k0) for b_op in h_basis])
    for indx, t in enumerate(t_span):
        phi = linalg.expm(hij * t) @ phi0
        k_inst = k_state_from_phi_basis(phi, h_basis)
        result.append(k_inst)
    return result


def series_evolution(ham, k0, t_span, order) -> List[Operator]:
    """
    Compute the solution of the Schrödinger equation

    dk
    -- = -i [H, k]
    dt

    as a linear combination of the iterated commutators

    k = k0 - i [H, k0] t - [H,[H, k0]] t**2 - ...

    Parameters
    ----------
    ham : Operator
        The Hamiltonian operator
    k0 : Operator
        The initial condition
    t_span: np.array
        the times for with the evolution is computed
    order:
        the order of the solution

    Returns
    -------
    List[Operator]:
        A list with the solution at times t_span

    """
    # TODO: implement me for time-dependent hamiltonians
    # an solve in the interaction picture
    h_basis = build_hierarchical_basis(ham, k0, order)
    return [
        sum((t) ** p * bb / factorial(p) for p, bb in enumerate(h_basis))
        for t in t_span
    ]